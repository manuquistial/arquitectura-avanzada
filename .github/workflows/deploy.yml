name: Deploy to AKS

on:
  push:
    branches:
      - master
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        type: choice
        options:
          - dev
          - staging
          - prod

env:
  AZURE_REGION: eastus
  TERRAFORM_VERSION: 1.6.0
  HELM_VERSION: 3.13.0

jobs:
  terraform:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'dev' }}
    
    outputs:
      resource_group: ${{ steps.terraform-output.outputs.resource_group }}
      cluster_name: ${{ steps.terraform-output.outputs.cluster_name }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false
      
      - name: Azure Login
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      
      - name: Terraform Init
        working-directory: infra/terraform
        run: terraform init
      
      - name: Create terraform.tfvars
        working-directory: infra/terraform
        run: |
          cat > terraform.tfvars << EOF
          environment = "${{ github.event.inputs.environment || 'dev' }}"
          
          # Database
          db_admin_username = "${{ secrets.DB_ADMIN_USERNAME }}"
          db_admin_password = "${{ secrets.DB_ADMIN_PASSWORD }}"
          
          # OpenSearch
          opensearch_username = "admin"
          opensearch_password = "${{ secrets.OPENSEARCH_PASSWORD }}"
          
          # cert-manager
          letsencrypt_email = "${{ secrets.LETSENCRYPT_EMAIL }}"
          
          # Domain (if available)
          domain_name = "${{ secrets.DOMAIN_NAME || '' }}"
          enable_tls = ${{ secrets.DOMAIN_NAME != '' }}
          EOF
      
      - name: Terraform Plan
        working-directory: infra/terraform
        run: terraform plan -out=tfplan
      
      - name: Terraform Apply
        working-directory: infra/terraform
        run: terraform apply -auto-approve tfplan
      
      - name: Export Terraform Outputs
        id: terraform-output
        working-directory: infra/terraform
        run: |
          echo "resource_group=$(terraform output -raw resource_group_name)" >> $GITHUB_OUTPUT
          echo "cluster_name=$(terraform output -raw aks_cluster_name)" >> $GITHUB_OUTPUT
          
          # Export sensitive outputs to files (not to GITHUB_OUTPUT)
          terraform output -raw resource_group_name > /tmp/resource_group.txt
          terraform output -raw postgresql_fqdn > /tmp/postgres_host.txt
          terraform output -raw postgresql_admin_username > /tmp/postgres_user.txt
          terraform output -raw servicebus_connection_string > /tmp/servicebus_conn.txt
          terraform output -raw storage_account_name > /tmp/storage_account.txt
      
      - name: Upload Terraform Outputs
        uses: actions/upload-artifact@v4
        with:
          name: terraform-outputs
          path: |
            /tmp/postgres_host.txt
            /tmp/postgres_user.txt
            /tmp/servicebus_conn.txt
            /tmp/storage_account.txt
          retention-days: 1

  deploy-app:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: terraform
    environment: ${{ github.event.inputs.environment || 'dev' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Download Terraform Outputs
        uses: actions/download-artifact@v4
        with:
          name: terraform-outputs
          path: /tmp
      
      - name: Azure Login
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      
      - name: Get AKS Credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ needs.terraform.outputs.resource_group }} \
            --name ${{ needs.terraform.outputs.cluster_name }} \
            --overwrite-existing
      
      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: ${{ env.HELM_VERSION }}
      
      - name: Install Nginx Ingress Controller
        run: |
          if ! helm list -n ingress-nginx | grep -q nginx-ingress; then
            helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
            helm repo update
            
            helm install nginx-ingress ingress-nginx/ingress-nginx \
              --namespace ingress-nginx \
              --create-namespace \
              --set controller.service.type=LoadBalancer \
              --set controller.metrics.enabled=true \
              --wait \
              --timeout 5m
          else
            echo "Nginx Ingress already installed"
          fi
      
      - name: Create Kubernetes Secrets
        env:
          NAMESPACE: ${{ github.event.inputs.environment == 'prod' && 'carpeta-ciudadana-prod' || 'default' }}
          DB_ADMIN_PASSWORD: ${{ secrets.DB_ADMIN_PASSWORD }}
          OPENSEARCH_PASSWORD: ${{ secrets.OPENSEARCH_PASSWORD }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD || '' }}
          SMTP_HOST: ${{ secrets.SMTP_HOST || '' }}
          SMTP_PORT: ${{ secrets.SMTP_PORT || '587' }}
          SMTP_USER: ${{ secrets.SMTP_USER || '' }}
          SMTP_PASS: ${{ secrets.SMTP_PASSWORD || '' }}
          SMTP_FROM: ${{ secrets.SMTP_FROM || 'noreply@carpeta-ciudadana.example.com' }}
          ACS_ENDPOINT: ${{ secrets.ACS_ENDPOINT || '' }}
          ACS_KEY: ${{ secrets.ACS_KEY || '' }}
        run: |
          # Read Terraform outputs
          POSTGRES_HOST=$(cat /tmp/postgres_host.txt)
          POSTGRES_USER=$(cat /tmp/postgres_user.txt)
          SERVICEBUS_CONN=$(cat /tmp/servicebus_conn.txt)
          STORAGE_ACCOUNT=$(cat /tmp/storage_account.txt)
          
          kubectl config set-context --current --namespace="$NAMESPACE"
          
          # 1. Database Secret
          DATABASE_URL="postgresql+asyncpg://${POSTGRES_USER}:${DB_ADMIN_PASSWORD}@${POSTGRES_HOST}:5432/carpeta_ciudadana"
          POSTGRES_URI="postgresql://${POSTGRES_USER}:${DB_ADMIN_PASSWORD}@${POSTGRES_HOST}:5432/carpeta_ciudadana"
          
          kubectl create secret generic carpeta-ciudadana-database \
            --from-literal=DATABASE_URL="$DATABASE_URL" \
            --from-literal=POSTGRES_URI="$POSTGRES_URI" \
            --dry-run=client -o yaml | kubectl apply -f -
          
          # 2. Service Bus Secret
          kubectl create secret generic sb-conn \
            --from-literal=SERVICEBUS_CONNECTION_STRING="$SERVICEBUS_CONN" \
            --dry-run=client -o yaml | kubectl apply -f -
          
          # 3. Azure Storage Secret (if Terraform manages it)
          # Note: Managed Identity is preferred, this is fallback
          
          # 4. Redis Secret
          kubectl create secret generic redis-password \
            --from-literal=password="$REDIS_PASSWORD" \
            --dry-run=client -o yaml | kubectl apply -f -
          
          # 5. SMTP Secret
          kubectl create secret generic smtp-credentials \
            --from-literal=SMTP_HOST="$SMTP_HOST" \
            --from-literal=SMTP_PORT="$SMTP_PORT" \
            --from-literal=SMTP_USER="$SMTP_USER" \
            --from-literal=SMTP_PASSWORD="$SMTP_PASS" \
            --from-literal=SMTP_FROM="$SMTP_FROM" \
            --dry-run=client -o yaml | kubectl apply -f -
          
          # 6. ACS Secret
          kubectl create secret generic acs-credentials \
            --from-literal=ACS_ENDPOINT="$ACS_ENDPOINT" \
            --from-literal=ACS_KEY="$ACS_KEY" \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "✅ All secrets created/updated"
      
      - name: Deploy with Helm
        env:
          NAMESPACE: ${{ github.event.inputs.environment == 'prod' && 'carpeta-ciudadana-prod' || 'default' }}
          ENVIRONMENT: ${{ github.event.inputs.environment || 'dev' }}
        run: |
          cd deploy/helm
          
          # Read Terraform outputs
          POSTGRES_HOST=$(cat /tmp/postgres_host.txt)
          STORAGE_ACCOUNT=$(cat /tmp/storage_account.txt)
          SERVICEBUS_CONN=$(cat /tmp/servicebus_conn.txt)
          
          # Determinar values file
          if [ "$ENVIRONMENT" = "prod" ]; then
            VALUES_FILE="values-prod.yaml"
          else
            VALUES_FILE="values-dev.yaml"
          fi
          
          # Deploy
          helm upgrade --install carpeta-ciudadana ./carpeta-ciudadana \
            -f carpeta-ciudadana/values.yaml \
            -f "$VALUES_FILE" \
            --set postgresql.host="$POSTGRES_HOST" \
            --set azure.storage.accountName="$STORAGE_ACCOUNT" \
            --set serviceBus.connectionString="$SERVICEBUS_CONN" \
            --set serviceBus.enabled=true \
            --namespace "$NAMESPACE" \
            --create-namespace \
            --wait \
            --timeout 15m
          
          echo "✅ Helm deployment complete"
      
      - name: Verify Deployment
        env:
          NAMESPACE: ${{ github.event.inputs.environment == 'prod' && 'carpeta-ciudadana-prod' || 'default' }}
        run: |
          echo "Checking pods..."
          kubectl get pods -n "$NAMESPACE"
          
          echo ""
          echo "Checking services..."
          kubectl get svc -n "$NAMESPACE"
          
          echo ""
          echo "Checking ingress..."
          kubectl get ingress -n "$NAMESPACE"
          
          echo ""
          echo "Checking migration jobs..."
          kubectl get jobs -n "$NAMESPACE" | grep migrate || echo "No migration jobs found"
      
      - name: Remove Temporary Firewall Rule
        if: always()  # Always run, even if previous steps failed
        run: |
          if [ -f /tmp/firewall_rule_name.txt ]; then
            RESOURCE_GROUP=$(cat /tmp/resource_group.txt)
            POSTGRES_HOST=$(cat /tmp/postgres_host.txt)
            SERVER_NAME=$(echo $POSTGRES_HOST | cut -d'.' -f1)
            RULE_NAME=$(cat /tmp/firewall_rule_name.txt)
            
            echo "Removing temporary firewall rule: $RULE_NAME"
            az postgres flexible-server firewall-rule delete \
              --resource-group "$RESOURCE_GROUP" \
              --name "$SERVER_NAME" \
              --rule-name "$RULE_NAME" \
              --yes \
              || echo "Failed to remove firewall rule, may need manual cleanup"
          else
            echo "No firewall rule to remove"
          fi
      
      - name: Get Access URLs
        env:
          NAMESPACE: ${{ github.event.inputs.environment == 'prod' && 'carpeta-ciudadana-prod' || 'default' }}
        run: |
          echo ""
          echo "========================================="
          echo "Deployment Information"
          echo "========================================="
          echo "Environment: ${{ github.event.inputs.environment || 'dev' }}"
          echo "Namespace: $NAMESPACE"
          echo ""
          
          INGRESS_IP=$(kubectl get svc -n ingress-nginx nginx-ingress-ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "pending")
          
          if [ "$INGRESS_IP" != "pending" ]; then
            echo "Access URLs:"
            echo "  Frontend: http://$INGRESS_IP"
            echo "  API:      http://$INGRESS_IP/api"
          else
            echo "LoadBalancer IP is pending..."
            echo "Check with: kubectl get svc -n ingress-nginx"
          fi
          
          echo ""
          echo "========================================="

