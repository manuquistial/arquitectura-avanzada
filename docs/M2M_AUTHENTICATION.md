# üîí Machine-to-Machine (M2M) Authentication

**Fecha**: 2025-10-13  
**Versi√≥n**: 1.0  
**Autor**: Manuel Jurado

Documentaci√≥n del protocolo de autenticaci√≥n M2M para comunicaci√≥n entre servicios.

---

## üìã √çndice

1. [Descripci√≥n General](#descripci√≥n-general)
2. [Protocolo de Headers](#protocolo-de-headers)
3. [Generaci√≥n de Signature](#generaci√≥n-de-signature)
4. [Validaci√≥n de Headers](#validaci√≥n-de-headers)
5. [Replay Protection](#replay-protection)
6. [Integraci√≥n](#integraci√≥n)
7. [Configuraci√≥n](#configuraci√≥n)
8. [Testing](#testing)
9. [Troubleshooting](#troubleshooting)

---

## üéØ Descripci√≥n General

El protocolo M2M autentica las llamadas entre microservicios usando **HMAC-SHA256** con protecci√≥n contra replay attacks.

### Caracter√≠sticas

‚úÖ **HMAC-SHA256**: Firma criptogr√°fica de headers + body  
‚úÖ **Replay Protection**: Nonce √∫nico + timestamp validation  
‚úÖ **Redis Deduplication**: Nonces almacenados en Redis (TTL 10 minutos)  
‚úÖ **Constant-time comparison**: Previene timing attacks  
‚úÖ **Graceful degradation**: Funciona sin Redis (modo degradado)  

---

## üîê Protocolo de Headers

### Headers Requeridos

Todas las llamadas M2M deben incluir 4 headers:

| Header | Descripci√≥n | Ejemplo |
|--------|-------------|---------|
| `X-Service-Id` | Identificador del servicio caller | `gateway` |
| `X-Nonce` | Valor √∫nico aleatorio (32 bytes hex) | `a1b2c3d4e5f6...` (64 chars) |
| `X-Timestamp` | Unix timestamp (segundos) | `1697155200` |
| `X-Signature` | HMAC-SHA256 signature | `e4f5a6b7c8d9...` (64 chars) |

### Ejemplo de Request

```http
POST /api/citizens HTTP/1.1
Host: citizen-service:8000
Content-Type: application/json
X-Service-Id: gateway
X-Nonce: a1b2c3d4e5f6789012345678901234567890abcdef1234567890abcdef123456
X-Timestamp: 1697155200
X-Signature: e4f5a6b7c8d9012345678901234567890abcdef1234567890abcdef12345678

{"name": "Carlos Andres", "email": "carlos@example.com"}
```

---

## üîß Generaci√≥n de Signature

### Algoritmo

```
message = service_id + "|" + nonce + "|" + timestamp + "|" + body
signature = HMAC-SHA256(secret_key, message)
```

### Paso a Paso

1. **Generar nonce**: 32 bytes random ‚Üí hex (64 chars)
2. **Generar timestamp**: `int(time.time())`
3. **Build message**:
   ```python
   message = f"{service_id}|{nonce}|{timestamp}|{json.dumps(body)}".encode()
   ```
4. **Generate HMAC**:
   ```python
   signature = hmac.new(secret_key, message, hashlib.sha256).hexdigest()
   ```

### Ejemplo en Python

```python
from carpeta_common.m2m_auth import M2MAuthGenerator

# Initialize generator
generator = M2MAuthGenerator(
    service_id="gateway",
    secret_key="shared-secret-key-123"
)

# Generate headers
headers = generator.generate_headers(body=b'{"name": "Carlos"}')

# Headers ready to use
# {
#   "X-Service-Id": "gateway",
#   "X-Nonce": "a1b2c3...",
#   "X-Timestamp": "1697155200",
#   "X-Signature": "e4f5a6..."
# }
```

---

## ‚úÖ Validaci√≥n de Headers

### Proceso de Validaci√≥n

1. **Check presence**: Todos los headers deben estar presentes
2. **Validate timestamp**: Debe estar dentro de ventana permitida (5 minutos)
3. **Validate nonce**: No debe haber sido usado antes (Redis check)
4. **Validate signature**: HMAC debe coincidir

### Ejemplo en Python

```python
from carpeta_common.m2m_auth import M2MAuthValidator

# Initialize validator
validator = M2MAuthValidator(
    secret_key="shared-secret-key-123",
    redis_client=redis_client,
    max_timestamp_age=300  # 5 minutes
)

# Validate headers
service_id = await validator.validate_headers(
    service_id=request.headers.get("X-Service-Id"),
    nonce=request.headers.get("X-Nonce"),
    timestamp=request.headers.get("X-Timestamp"),
    signature=request.headers.get("X-Signature"),
    body=await request.body()
)

# If we get here, authentication succeeded
print(f"Authenticated service: {service_id}")
```

### Como Dependency FastAPI

```python
from fastapi import Depends
from carpeta_common.m2m_auth import get_m2m_auth

@app.post("/internal/endpoint")
async def internal_endpoint(
    caller_service: str = Depends(get_m2m_auth)
):
    return {"caller": caller_service, "message": "Authenticated"}
```

---

## üõ°Ô∏è Replay Protection

### Mecanismo

1. **Nonce Deduplication**: Cada nonce solo puede usarse una vez
2. **Timestamp Window**: Request debe ser reciente (< 5 minutos)
3. **Redis Storage**: Nonces almacenados con TTL de 10 minutos

### Flujo

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Request      ‚îÇ
‚îÇ with nonce   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Check nonce in Redis     ‚îÇ
‚îÇ Key: m2m:nonce:{service}:{nonce} ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚îú‚îÄ Exists? ‚Üí ‚ùå Reject (replay attack)
       ‚îÇ
       ‚îî‚îÄ Not exists? ‚Üí ‚úÖ Continue
          ‚îÇ
          ‚ñº
       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       ‚îÇ Store nonce    ‚îÇ
       ‚îÇ TTL: 10 min    ‚îÇ
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Ventana de Tiempo

```
Current time: 1697155200
Request timestamp: 1697155100 (100 seconds ago)

‚úÖ Valid (< 300 seconds)

Request timestamp: 1697154800 (400 seconds ago)

‚ùå Invalid (> 300 seconds)
```

---

## üîå Integraci√≥n

### En Servicio Caller (Gateway)

```python
from carpeta_common.http_client import M2MHttpClient

# Initialize client
client = M2MHttpClient(
    service_id="gateway",
    secret_key="shared-secret-key"
)

# Make authenticated request
response = await client.post(
    "http://citizen-service:8000/api/citizens",
    json={"name": "Carlos", "email": "carlos@example.com"}
)

# Headers are added automatically:
# X-Service-Id: gateway
# X-Nonce: <random>
# X-Timestamp: <current>
# X-Signature: <hmac>
```

### En Servicio Receiver (Citizen)

```python
from fastapi import Depends
from carpeta_common.m2m_auth import get_m2m_auth

@router.post("/api/citizens")
async def create_citizen(
    data: CitizenCreate,
    caller_service: str = Depends(get_m2m_auth)
):
    logger.info(f"Request from service: {caller_service}")
    
    # Process request
    # ...
    
    return {"id": 123, "name": data.name}
```

---

## ‚öôÔ∏è Configuraci√≥n

### Variables de Entorno

#### Servicio Caller
```env
SERVICE_ID=gateway
M2M_SECRET_KEY=your-shared-secret-key-here
```

#### Servicio Receiver
```env
M2M_SECRET_KEY=your-shared-secret-key-here
M2M_MAX_TIMESTAMP_AGE=300
REDIS_HOST=redis
REDIS_PORT=6379
```

### Kubernetes Secrets

```bash
# Generate secure secret key
SECRET_KEY=$(openssl rand -hex 32)

# Create secret
kubectl create secret generic m2m-auth \
  --from-literal=M2M_SECRET_KEY=$SECRET_KEY \
  --namespace carpeta-ciudadana-dev
```

### Helm Values

```yaml
global:
  m2mAuth:
    enabled: true
    secretName: m2m-auth
    maxTimestampAge: 300
    nonceTtl: 600

# Reference in deployment
envFrom:
- secretRef:
    name: m2m-auth
```

---

## üß™ Testing

### Test Manual

```bash
# 1. Generate headers (Python)
python3 << 'EOF'
from carpeta_common.m2m_auth import M2MAuthGenerator
import json

gen = M2MAuthGenerator("test-service", "secret-key-123")
body = json.dumps({"test": "data"}).encode()
headers = gen.generate_headers(body)

print("Headers:")
for k, v in headers.items():
    print(f"{k}: {v}")
EOF

# 2. Make request with headers
curl -X POST http://citizen-service:8000/api/citizens \
  -H "Content-Type: application/json" \
  -H "X-Service-Id: test-service" \
  -H "X-Nonce: <generated-nonce>" \
  -H "X-Timestamp: <generated-timestamp>" \
  -H "X-Signature: <generated-signature>" \
  -d '{"test": "data"}'
```

### Test Unitarios

```python
import pytest
from carpeta_common.m2m_auth import M2MAuthGenerator, M2MAuthValidator

@pytest.mark.asyncio
async def test_valid_auth():
    secret_key = "test-secret"
    service_id = "test-service"
    
    # Generate
    gen = M2MAuthGenerator(service_id, secret_key)
    nonce = gen.generate_nonce()
    timestamp = gen.generate_timestamp()
    body = b'{"test": "data"}'
    signature = gen.generate_signature(nonce, timestamp, body)
    
    # Validate
    validator = M2MAuthValidator(secret_key)
    result = await validator.validate_headers(
        service_id, nonce, timestamp, signature, body
    )
    
    assert result == service_id

@pytest.mark.asyncio
async def test_replay_attack():
    """Test nonce reuse is rejected"""
    # ... (ver test_m2m_auth.py)
```

---

## üîç Troubleshooting

### Error: "Missing M2M headers"

**Causa**: Request sin headers M2M.

**Soluci√≥n**:
- Usar `M2MHttpClient` en vez de `httpx` directo
- Verificar que headers se est√°n generando

### Error: "Timestamp too old"

**Causa**: Reloj desincronizado entre servicios.

**Soluci√≥n**:
- Sincronizar relojes (NTP)
- Aumentar `M2M_MAX_TIMESTAMP_AGE` temporalmente
- Verificar timezone de pods

### Error: "Nonce already used"

**Causa**: Nonce reutilizado (replay attack o retry).

**Soluci√≥n**:
- **Si es retry leg√≠timo**: Generar nuevo nonce
- **Si es replay attack**: Investigar origen del request

### Error: "Invalid signature"

**Causa**: Secret key diferente o body modificado.

**Soluci√≥n**:
- Verificar que `M2M_SECRET_KEY` es id√©ntico en caller y receiver
- Verificar que body no est√° siendo modificado
- Verificar orden de campos en JSON (usar `sort_keys=True`)

### Warning: "Continuing without nonce validation"

**Causa**: Redis no disponible.

**Soluci√≥n**:
- Verificar Redis est√° corriendo
- Verificar `REDIS_HOST` y `REDIS_PORT`
- **Nota**: Sistema funciona en modo degradado (sin replay protection)

---

## üìä M√©tricas y Monitoring

### Prometheus Metrics (TODO)

```prometheus
# Total M2M requests validated
m2m_auth_requests_total{service_id="gateway", status="success"} 1234

# M2M validation errors
m2m_auth_errors_total{service_id="gateway", error_type="invalid_signature"} 5

# Replay attacks detected
m2m_auth_replay_attacks_total{service_id="gateway"} 2

# Nonce cache hits
m2m_nonce_cache_hits_total 123
```

### Alertas (TODO)

```yaml
- alert: M2MHighErrorRate
  expr: rate(m2m_auth_errors_total[5m]) > 0.1
  annotations:
    summary: "M2M auth error rate > 10%"

- alert: M2MReplayAttacks
  expr: increase(m2m_auth_replay_attacks_total[1h]) > 10
  annotations:
    summary: "Multiple replay attacks detected"
```

---

## üîë Seguridad

### Best Practices

‚úÖ **Secret rotation**: Rotar `M2M_SECRET_KEY` peri√≥dicamente (90 d√≠as)  
‚úÖ **Strong secret**: M√≠nimo 32 bytes random (usar `openssl rand -hex 32`)  
‚úÖ **Redis HA**: Usar Redis Cluster para alta disponibilidad  
‚úÖ **Monitoring**: Alertas para errores de validaci√≥n  
‚úÖ **Logging**: Log de replay attacks para investigaci√≥n  

### Consideraciones

‚ö†Ô∏è **Secret compartido**: Todos los servicios usan el mismo secret  
‚ö†Ô∏è **Body inmutable**: No modificar body despu√©s de firmar  
‚ö†Ô∏è **Clock sync**: Servicios deben tener relojes sincronizados (NTP)  
‚ö†Ô∏è **Redis dependency**: Sin Redis, no hay replay protection  

---

## üìö Ejemplos de Uso

### Ejemplo 1: Gateway ‚Üí Citizen Service

```python
# Gateway service (caller)
from carpeta_common.http_client import M2MHttpClient

client = M2MHttpClient(
    service_id="gateway",
    secret_key=os.getenv("M2M_SECRET_KEY")
)

response = await client.post(
    "http://citizen-service:8000/api/citizens",
    json={"name": "Carlos", "email": "carlos@example.com"}
)

# Citizen service (receiver)
from fastapi import Depends
from carpeta_common.m2m_auth import get_m2m_auth

@router.post("/api/citizens")
async def create_citizen(
    data: CitizenCreate,
    caller: str = Depends(get_m2m_auth)
):
    logger.info(f"Request from: {caller}")  # "gateway"
    # Process...
```

### Ejemplo 2: Transfer Service ‚Üí Notification Service

```python
# Transfer service (caller)
from carpeta_common.http_client import m2m_request

response = await m2m_request(
    "POST",
    "http://notification-service:8010/api/notifications",
    json={
        "type": "transfer_completed",
        "recipient": "user@example.com",
        "data": {"transfer_id": "123"}
    }
)

# Notification service (receiver)
@router.post("/api/notifications")
async def send_notification(
    data: NotificationData,
    caller: str = Depends(get_m2m_auth)
):
    logger.info(f"Notification request from: {caller}")
    # Send notification...
```

---

## üîÑ Flujo Completo

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1. Gateway Service (Caller)                    ‚îÇ
‚îÇ    - Generate nonce (random 32 bytes)          ‚îÇ
‚îÇ    - Generate timestamp (current Unix time)    ‚îÇ
‚îÇ    - Generate signature (HMAC-SHA256)          ‚îÇ
‚îÇ    - Add headers to request                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚îÇ
              ‚îÇ HTTP Request with headers:
              ‚îÇ X-Service-Id: gateway
              ‚îÇ X-Nonce: a1b2c3...
              ‚îÇ X-Timestamp: 1697155200
              ‚îÇ X-Signature: e4f5a6...
              ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 2. Citizen Service (Receiver)                  ‚îÇ
‚îÇ    ‚úÖ Check headers present                     ‚îÇ
‚îÇ    ‚úÖ Validate timestamp (< 5 min old)          ‚îÇ
‚îÇ    ‚úÖ Check nonce in Redis (not used)           ‚îÇ
‚îÇ    ‚úÖ Validate signature (HMAC match)           ‚îÇ
‚îÇ    ‚úÖ Store nonce in Redis (TTL 10 min)         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚îÇ
              ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 3. Process Request                              ‚îÇ
‚îÇ    - Authenticated as "gateway"                 ‚îÇ
‚îÇ    - Process business logic                     ‚îÇ
‚îÇ    - Return response                            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üì¶ Componentes

### carpeta_common/m2m_auth.py

**Clases**:
- `M2MAuthGenerator`: Genera headers
- `M2MAuthValidator`: Valida headers
- `M2MAuthMiddleware`: FastAPI dependency

**Funciones**:
- `get_m2m_auth()`: Dependency para FastAPI
- `create_m2m_generator()`: Helper para crear generator
- `create_m2m_validator()`: Helper para crear validator

### carpeta_common/http_client.py

**Clases**:
- `M2MHttpClient`: HTTP client con M2M autom√°tico

**M√©todos**:
- `get(url)`: GET con M2M auth
- `post(url, json)`: POST con M2M auth
- `put(url, json)`: PUT con M2M auth
- `delete(url)`: DELETE con M2M auth

**Funciones**:
- `m2m_request(method, url, **kwargs)`: Single request helper

---

## üéì Best Practices

### 1. Usar M2MHttpClient para Internal Calls

```python
# ‚ùå NO HACER (sin autenticaci√≥n)
async with httpx.AsyncClient() as client:
    response = await client.post("http://citizen-service/api/citizens", json=data)

# ‚úÖ HACER (con M2M auth)
from carpeta_common.http_client import M2MHttpClient

client = M2MHttpClient("gateway", secret_key)
response = await client.post("http://citizen-service/api/citizens", json=data)
```

### 2. Proteger Endpoints Internos

```python
from carpeta_common.m2m_auth import get_m2m_auth

# ‚ùå Endpoint sin protecci√≥n
@router.post("/internal/process")
async def process():
    # Cualquiera puede llamar
    pass

# ‚úÖ Endpoint protegido con M2M
@router.post("/internal/process")
async def process(caller: str = Depends(get_m2m_auth)):
    # Solo servicios autenticados pueden llamar
    logger.info(f"Called by: {caller}")
    pass
```

### 3. Manejar Errores

```python
try:
    response = await client.post(url, json=data)
    response.raise_for_status()
except httpx.HTTPStatusError as e:
    if e.response.status_code == 401:
        logger.error("M2M authentication failed")
    raise
```

---

## üìã Checklist de Implementaci√≥n

- [x] M2MAuthGenerator implementado
- [x] M2MAuthValidator implementado
- [x] M2MHttpClient implementado
- [x] Redis nonce deduplication
- [x] FastAPI dependency (get_m2m_auth)
- [x] Tests unitarios
- [x] Documentaci√≥n completa
- [ ] Integraci√≥n en todos los servicios
- [ ] Prometheus metrics
- [ ] Alertas configuradas
- [ ] Load testing
- [ ] Secret rotation automation

---

## üöÄ Roadmap

### Futuras Mejoras

- [ ] **JWT-based M2M**: Usar JWT en vez de HMAC para m√°s flexibilidad
- [ ] **Service mesh**: Considerar Istio/Linkerd para mTLS autom√°tico
- [ ] **Rate limiting**: Por service_id
- [ ] **Audit logging**: Log de todas las llamadas M2M
- [ ] **Prometheus metrics**: M√©tricas detalladas
- [ ] **Distributed tracing**: OpenTelemetry integration

---

## üìö Referencias

- [HMAC: Keyed-Hashing for Message Authentication (RFC 2104)](https://datatracker.ietf.org/doc/html/rfc2104)
- [Python hmac module](https://docs.python.org/3/library/hmac.html)
- [FastAPI Dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/)
- [Redis SETEX](https://redis.io/commands/setex/)

---

**Generado**: 2025-10-13 01:30  
**Autor**: Manuel Jurado  
**Versi√≥n**: 1.0

