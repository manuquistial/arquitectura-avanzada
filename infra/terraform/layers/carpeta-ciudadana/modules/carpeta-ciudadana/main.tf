# Carpeta Ciudadana Helm Chart Module

# Local values for auto-detection
locals {
  # Auto-detect frontend URL - use provided URL or placeholder
  frontend_url_auto = var.frontend_url != "" ? var.frontend_url : "http://LOADBALANCER-IP-PENDING"
}

# Helm Release for Carpeta Ciudadana
resource "helm_release" "carpeta_ciudadana" {
  name       = "carpeta-ciudadana"
  chart      = var.chart_path
  version    = var.chart_version
  namespace  = var.namespace
  create_namespace = true
  timeout    = var.timeout

  values = [
    file("${var.chart_path}/values.yaml")
  ]

  # Valores din√°micos para Key Vault
  set {
    name  = "keyvault.vaultUrl"
    value = var.key_vault_uri
  }

  set {
    name  = "keyvault.clientId"
    value = var.workload_identity_client_id
  }

  set {
    name  = "global.workloadIdentity.clientId"
    value = var.workload_identity_client_id
  }

  set {
    name  = "global.workloadIdentity.tenantId"
    value = var.workload_identity_tenant_id
  }

  # Frontend configuration - Use auto-detected URL
  set {
    name  = "frontend.nextAuth.url"
    value = local.frontend_url_auto
  }

  # NextAuth secret will be loaded from Kubernetes secret (generated by application-secrets module)

  # Ingress configuration
  set {
    name  = "ingress.hosts[0].host"
    value = var.domain_name
  }

  # Dependencias manejadas por el layer principal
}

# Kubernetes Secret for database credentials
resource "kubernetes_secret" "database_credentials" {
  metadata {
    name      = "database-credentials"
    namespace = var.namespace
  }

  data = {
    username = var.database_username
    password = var.database_password
  }

  type = "Opaque"
}

# Kubernetes Secret for Redis credentials
resource "kubernetes_secret" "redis_credentials" {
  metadata {
    name      = "redis-credentials"
    namespace = var.namespace
  }

  data = {
    password = var.redis_password
  }

  type = "Opaque"
}

# Kubernetes Secret for storage credentials
resource "kubernetes_secret" "storage_credentials" {
  metadata {
    name      = "storage-credentials"
    namespace = var.namespace
  }

  data = {
    accountName = var.storage_account_name
    accountKey  = var.storage_account_key
  }

  type = "Opaque"
}

# Data source to get LoadBalancer IP/FQDN after deployment
data "kubernetes_service" "frontend_lb" {
  metadata {
    name      = "carpeta-ciudadana-frontend"
    namespace = var.namespace
  }
  depends_on = [helm_release.carpeta_ciudadana]
}

# Update frontend URL after LoadBalancer is ready
resource "null_resource" "update_frontend_url" {
  count = var.frontend_url == "" ? 1 : 0
  
  triggers = {
    service_ready = data.kubernetes_service.frontend_lb.status.0.load_balancer.0.ingress.0.ip
  }

  provisioner "local-exec" {
    command = <<-EOT
      echo "Frontend URL: http://${data.kubernetes_service.frontend_lb.status.0.load_balancer.0.ingress.0.ip}"
      echo "Update your terraform.tfvars with:"
      echo "frontend_url = \"http://${data.kubernetes_service.frontend_lb.status.0.load_balancer.0.ingress.0.ip}\""
    EOT
  }
}
