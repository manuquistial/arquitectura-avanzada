# Default values for carpeta-ciudadana

global:
  environment: development
  imageRegistry: manuelquistial
  imagePullPolicy: IfNotPresent
  logLevel: INFO
  useWorkloadIdentity: true
  
  # M2M Authentication (inter-service communication)
  m2mAuth:
    enabled: true
    secretName: m2m-auth
    secretKey: ""  # Set via --set or secret (generate with: openssl rand -hex 32)
    maxTimestampAge: 300  # 5 minutes
    nonceTtl: 600  # 10 minutes

# Frontend
frontend:
  enabled: true
  replicaCount: 2
  image:
    repository: carpeta-frontend
    tag: latest
  service:
    type: LoadBalancer  # Público - acceso directo
    port: 80
    targetPort: 3000
  resources:
    requests:
      memory: "128Mi"  # Next.js puede correr con menos en dev
      cpu: "100m"
    limits:
      memory: "512Mi"  # Límite para evitar OOM
      cpu: "500m"
  autoscaling:
    enabled: true
    minReplicas: 2
    maxReplicas: 10
    targetCPUUtilizationPercentage: 70
    targetMemoryUtilizationPercentage: 80

# Gateway Service - Alto tráfico, crítico
gateway:
  enabled: true
  replicaCount: 3
  image:
    repository: carpeta-gateway
    tag: latest
  service:
    type: ClusterIP  # Interno - expuesto vía Ingress
    port: 8000
  resources:
    requests:
      memory: "256Mi"  # Rate limiter + proxying necesita más memoria
      cpu: "200m"
    limits:
      memory: "512Mi"  # Límite para evitar OOM bajo alta carga
      cpu: "1000m"     # Puede escalar CPU bajo carga
  autoscaling:
    enabled: true
    minReplicas: 3
    maxReplicas: 20
    targetCPUUtilizationPercentage: 70
    # Metrics adicionales (requiere Prometheus Adapter)
    customMetrics:
      enabled: false  # Activar si tienes Prometheus Adapter
      metrics:
        - type: Pods
          pods:
            metric:
              name: http_request_duration_seconds_p95
            target:
              type: AverageValue
              averageValue: "500m"  # 500ms p95 latency

# Citizen Service - Moderado uso
citizen:
  enabled: true
  replicaCount: 2
  image:
    repository: carpeta-citizen
    tag: latest
  service:
    type: ClusterIP  # Interno - acceso vía gateway
    port: 8000
  resources:
    requests:
      memory: "128Mi"  # CRUD simple, bajo consumo
      cpu: "100m"
    limits:
      memory: "256Mi"  # Límite conservador
      cpu: "500m"
  autoscaling:
    enabled: true
    minReplicas: 2
    maxReplicas: 10
    targetCPUUtilizationPercentage: 70

# Ingestion Service - Genera SAS URLs, no sube archivos
ingestion:
  enabled: true
  replicaCount: 2
  image:
    repository: carpeta-ingestion
    tag: latest
  service:
    type: ClusterIP  # Interno - acceso vía gateway
    port: 8000
  resources:
    requests:
      memory: "128Mi"  # Solo genera presigned URLs, no procesa archivos
      cpu: "100m"
    limits:
      memory: "256Mi"  # Límite conservador
      cpu: "500m"
  autoscaling:
    enabled: true
    minReplicas: 2
    maxReplicas: 15
    targetCPUUtilizationPercentage: 70

# Signature Service - Alto CPU (criptografía)
signature:
  enabled: true
  replicaCount: 2
  image:
    repository: carpeta-signature
    tag: latest
  service:
    type: ClusterIP  # Interno - acceso vía gateway
    port: 8000
  resources:
    requests:
      memory: "256Mi"  # Operaciones criptográficas necesitan RAM
      cpu: "200m"      # CPU importante para firmas
    limits:
      memory: "512Mi"  # Límite para prevenir OOM
      cpu: "1000m"     # Puede usar más CPU para operaciones intensivas
  autoscaling:
    enabled: true
    minReplicas: 2
    maxReplicas: 10
    targetCPUUtilizationPercentage: 70

# Metadata Service - Búsquedas en OpenSearch
metadata:
  enabled: true
  replicaCount: 2
  image:
    repository: carpeta-metadata
    tag: latest
  service:
    type: ClusterIP  # Interno - acceso vía gateway
    port: 8000
  resources:
    requests:
      memory: "128Mi"  # Búsquedas delegadas a OpenSearch
      cpu: "100m"
    limits:
      memory: "256Mi"  # Límite conservador
      cpu: "500m"
  autoscaling:
    enabled: true
    minReplicas: 2
    maxReplicas: 10
    targetCPUUtilizationPercentage: 70

# Transfer Service - Saga pattern, transaccional
transfer:
  enabled: true
  replicaCount: 2
  image:
    repository: carpeta-transfer
    tag: latest
  service:
    type: ClusterIP  # Interno - acceso vía gateway (cambiar de LoadBalancer)
    port: 8000
  resources:
    requests:
      memory: "256Mi"  # Saga pattern + DB transactions
      cpu: "200m"
    limits:
      memory: "512Mi"  # Límite para evitar OOM durante sagas complejas
      cpu: "1000m"     # Puede necesitar CPU para procesamiento concurrente
  autoscaling:
    enabled: true
    minReplicas: 2
    maxReplicas: 10
    targetCPUUtilizationPercentage: 70

# Sharing Service - Shortlinks (bajo uso)
sharing:
  enabled: true
  replicaCount: 2
  image:
    repository: carpeta-sharing
    tag: latest
  service:
    type: ClusterIP  # Interno - acceso vía gateway
    port: 8000
  resources:
    requests:
      memory: "64Mi"   # Servicio simple de shortlinks
      cpu: "50m"
    limits:
      memory: "128Mi"  # Límite bajo
      cpu: "200m"
  autoscaling:
    enabled: true
    minReplicas: 2
    maxReplicas: 10
    targetCPUUtilizationPercentage: 70

# Notification Service - Email + webhooks (bajo uso típicamente)
notification:
  enabled: true
  replicaCount: 2
  image:
    repository: carpeta-notification
    tag: latest
  service:
    type: ClusterIP  # Interno - consumidor de eventos
    port: 8010
  resources:
    requests:
      memory: "64Mi"   # Servicio simple de notificaciones
      cpu: "50m"
    limits:
      memory: "128Mi"  # Límite bajo, previene OOM
      cpu: "200m"
  autoscaling:
    enabled: true
    minReplicas: 2
    maxReplicas: 10
    targetCPUUtilizationPercentage: 70

# MinTIC Client Service - Rate limiter + Hub calls
minticClient:
  enabled: true
  replicaCount: 2
  image:
    repository: carpeta-mintic_client
    tag: latest
  service:
    type: ClusterIP  # Interno - llamado por otros servicios
    port: 8000
  resources:
    requests:
      memory: "128Mi"  # HTTP client + rate limiter
      cpu: "100m"
    limits:
      memory: "256Mi"  # Límite conservador
      cpu: "500m"
  autoscaling:
    enabled: true
    minReplicas: 2
    maxReplicas: 10
    targetCPUUtilizationPercentage: 70

# Read Models Service (CQRS) - Consumidor de eventos
readModels:
  enabled: true
  replicaCount: 2
  image:
    repository: carpeta-read-models
    tag: latest
  service:
    type: ClusterIP  # Interno - acceso vía gateway
    port: 8007
  resources:
    requests:
      memory: "128Mi"  # Event consumer + queries simples
      cpu: "100m"
    limits:
      memory: "256Mi"  # Límite conservador
      cpu: "500m"
  autoscaling:
    enabled: true
    minReplicas: 2
    maxReplicas: 10
    targetCPUUtilizationPercentage: 70

# Auth Service - OIDC Provider + Azure AD B2C
auth:
  enabled: true
  replicaCount: 2
  image:
    repository: carpeta-auth
    tag: latest
  service:
    type: ClusterIP  # Interno - acceso vía gateway
    port: 8011
  resources:
    requests:
      memory: "128Mi"  # Token validation + session management
      cpu: "100m"
    limits:
      memory: "256Mi"  # Límite conservador
      cpu: "500m"
  autoscaling:
    enabled: true
    minReplicas: 2
    maxReplicas: 10
    targetCPUUtilizationPercentage: 70

# Transfer Worker - Dedicated consumer for transfers (KEDA auto-scaling)
transferWorker:
  enabled: true
  replicaCount: 0  # KEDA controls replicas (scales from 0)
  image:
    repository: carpeta-transfer-worker
    tag: latest
  service:
    type: ClusterIP  # Interno - solo métricas
    port: 8012
  
  # Worker configuration
  queueName: "transfers"
  maxConcurrent: 10  # Max concurrent messages per pod
  prefetchCount: 20  # Prefetch messages for performance
  maxWaitTime: 60    # Max seconds to wait for messages
  
  # Resources (optimized for spot instances)
  resources:
    requests:
      memory: "256Mi"  # Message processing + DB connections
      cpu: "200m"
    limits:
      memory: "512Mi"  # Limit to prevent OOM
      cpu: "1000m"     # Can spike during high load
  
  # KEDA auto-scaling configuration
  keda:
    enabled: true
    pollingInterval: 30  # Check queue every 30 seconds
    cooldownPeriod: 300   # Wait 5 minutes before scaling down
    minReplicas: 0        # Scale to zero when queue is empty
    maxReplicas: 30       # Maximum replicas under load
    fallbackReplicas: 3   # Fallback if metrics unavailable
    scaleDownStabilization: 300  # Wait 5 min before scale down
    
    # Queue metrics
    queueName: "transfers"
    targetQueueLength: 5  # Target 5 messages per pod
    activationThreshold: 1  # Activate from 0 when 1+ messages
    triggerAuthName: "azure-servicebus-auth"
    
    # Additional triggers (optional)
    cpuTrigger:
      enabled: false
      targetUtilization: 70
    memoryTrigger:
      enabled: false
      targetUtilization: 80
  
  # Node selector for spot instances
  nodeSelector:
    workload: "workers"
    kubernetes.azure.com/scalesetpriority: "spot"
  
  # Tolerations for spot instances
  tolerations:
  - key: "kubernetes.azure.com/scalesetpriority"
    operator: "Equal"
    value: "spot"
    effect: "NoSchedule"
  
  # Anti-affinity (spread across nodes)
  affinity:
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
            - key: app
              operator: In
              values:
              - transfer-worker
          topologyKey: kubernetes.io/hostname
  
  # Graceful shutdown
  terminationGracePeriodSeconds: 60
  
  # Probes
  livenessProbe:
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 3
  readinessProbe:
    initialDelaySeconds: 20
    periodSeconds: 5
    timeoutSeconds: 3
    successThreshold: 1
    failureThreshold: 2
  
  # Prometheus monitoring
  serviceMonitor:
    enabled: true
  
  # Pod annotations
  podAnnotations:
    prometheus.io/scrape: "true"
    prometheus.io/port: "8012"
    prometheus.io/path: "/metrics"

# PostgreSQL Configuration (Azure Database for PostgreSQL)
postgresql:
  enabled: true
  host: carpeta-db-server.postgres.database.azure.com
  port: 5432
  auth:
    username: carpeta_admin
    password: "" # Set via --set postgresql.auth.password=xxx or secret
    database: carpeta_ciudadana

# Azure Storage Configuration
azure:
  storage:
    accountName: "" # Set via --set azure.storage.accountName=xxx or secret
    accountKey: "" # Set via --set azure.storage.accountKey=xxx or secret
    containerName: "documents"
    sasTtlMinutes: 15

# Circuit Breaker Configuration
circuitBreaker:
  window: "60s"
  threshold: 5
  cooldown: "120s"

# Service Bus Configuration
serviceBus:
  enabled: true
  connectionString: "" # Set via --set serviceBus.connectionString or from Terraform output
  namespace: "" # Service Bus namespace (e.g., carpeta-sb) - for KEDA

# Observability Configuration
observability:
  enabled: true
  otel:
    endpoint: "http://otel-collector-opentelemetry-collector.observability.svc.cluster.local:4317"
  prometheus:
    enabled: true
    scrapeInterval: 30s

# CORS Configuration
cors:
  allowedOrigins: "*"  # Overridden in values-dev.yaml and values-prod.yaml
  allowCredentials: false

# OpenSearch Configuration
opensearch:
  enabled: true
  image:
    repository: opensearchproject/opensearch
    tag: "2.11.0"
    pullPolicy: IfNotPresent
  
  # Authentication
  auth:
    username: "admin"
    password: "Admin@123"  # Change in production
  
  security:
    enabled: false  # Set to true for production
  
  # Storage
  storage:
    size: "8Gi"
    storageClass: "managed-premium"  # Azure Premium SSD
  
  # Java heap size
  javaOpts:
    xms: "512m"
    xmx: "512m"
  
  # Resources
  resources:
    requests:
      memory: "1Gi"
      cpu: "500m"
    limits:
      memory: "2Gi"
      cpu: "1000m"
  
  # Service endpoint (for metadata service)
  host: "carpeta-ciudadana-opensearch"
  port: 9200

# Configuration
# OBSOLETE - AWS Configuration (migrated to Azure)
# config:
#   database:
#     host: YOUR_RDS_ENDPOINT
#     port: 5432
#     name: carpeta_ciudadana
#     username: carpeta_admin
#   s3:
#     bucket: YOUR_S3_BUCKET
#   opensearch:
#     host: YOUR_OPENSEARCH_ENDPOINT
#     port: 443
#   cognito:
#     region: us-east-1
#     userPoolId: YOUR_USER_POOL_ID
#     clientId: YOUR_CLIENT_ID
#   sqs:
#     queueUrl: YOUR_SQS_QUEUE_URL
#   sns:
#     topicArn: YOUR_SNS_TOPIC_ARN
#   mintic:
    hubUrl: https://govcarpeta-apis-4905ff3c005b.herokuapp.com
    allowInsecureUrls: false
    rateLimit: 10
    operatorId: YOUR_OPERATOR_ID
    operatorName: YOUR_OPERATOR_NAME
  otel:
    enabled: true
    endpoint: http://jaeger-collector:4317

# Service Account (for IRSA)
serviceAccount:
  create: true
  annotations: {}
  name: carpeta-ciudadana-sa

# Ingress - Solo expone frontend y gateway (público)
ingress:
  enabled: true
  className: nginx  # Use 'nginx' for cert-manager, 'alb' for AWS ALB
  annotations: {}
    # For AWS ALB (if using ALB instead of nginx):
    # alb.ingress.kubernetes.io/scheme: internet-facing
    # alb.ingress.kubernetes.io/target-type: ip
    # alb.ingress.kubernetes.io/certificate-arn: YOUR_ACM_CERT_ARN
    
    # For Azure Application Gateway (if using Azure):
    # appgw.ingress.kubernetes.io/ssl-redirect: "true"
  
  # Rate limiting
  rateLimitRps: 100  # Requests per second per IP
  
  tls:
    enabled: false  # Set to true when domain is configured
    secretName: carpeta-ciudadana-tls
    certManager:
      enabled: true
      # Use 'letsencrypt-staging' for dev/testing
      # Use 'letsencrypt-prod' for production
      clusterIssuer: letsencrypt-staging
      acmeChallenge: http01
      
  hosts:
    # If no domain available, leave host empty and TLS disabled
    # The application will be accessible via LoadBalancer IP
    - host: ""  # Set to your domain when available (e.g., carpeta-ciudadana.example.com)
      paths:
        # Frontend (public) - Serves static assets and UI
        - path: /
          pathType: Prefix
          backend:
            service:
              name: frontend
              port: 80
        # Gateway (public) - API endpoint, routes to internal services
        - path: /api
          pathType: Prefix
          backend:
            service:
              name: gateway
              port: 8000

# OpenTelemetry Collector
otel:
  enabled: true
  replicaCount: 2
  resources:
    requests:
      memory: "256Mi"
      cpu: "250m"
    limits:
      memory: "512Mi"
      cpu: "500m"

