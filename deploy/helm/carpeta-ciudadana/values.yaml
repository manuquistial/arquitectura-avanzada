# Default values for carpeta-ciudadana

global:
  environment: production
  imageRegistry: manuelquistial
  imagePullPolicy: Always
  logLevel: INFO
  useWorkloadIdentity: true
  highAvailability: true  # Habilitar alta disponibilidad
  workloadIdentity:
    clientId: ""  # Will be set via Kubernetes secret
    tenantId: ""   # Will be set via Kubernetes secret
  m2mAuth:
    enabled: true

# Migrations configuration
migrations:
  enabled: true  # Enabled for production
  azureB2C:
    enabled: true  # Enabled for production
  workloadIdentity:
    clientId: ""  # Will be set via Kubernetes secret
    tenantId: ""   # Will be set via Kubernetes secret
  # keyVault removed - using traditional Kubernetes secrets
  m2mAuth:
    enabled: true  # Enabled for inter-service authentication
  resourceOptimization:
    enabled: true  # Enable optimized resource settings
    maxReplicas: 3  # Maximum replicas per service in limited environments
    defaultRequests:
      cpu: "25m"
      memory: "128Mi"
    defaultLimits:
      cpu: "500m"
      memory: "512Mi"

# Service Bus configuration
servicebus:
  enabled: true  # Enabled for inter-service communication
  namespace: "prod-servicebus"


# CORS Configuration - Permitir dominios generados por Azure
corsOrigins: "*"  # Permitir todos los orígenes para dominios generados por Azure

# Security Headers - Configurado para HTTP
security:
  hstsEnabled: false  # Disabled for HTTP-only setup
  cspEnabled: false  # Disabled for HTTP-only setup
  cspReportUri: ""  # Optional CSP violation reporting endpoint

# Azure AD B2C configuration - Values will be set via Kubernetes secrets
azureB2C:
  enabled: true  # Enabled for production
  tenantName: ""  # Will be set via Kubernetes secret
  tenantId: ""    # Will be set via Kubernetes secret
  clientId: ""    # Will be set via Kubernetes secret
  clientSecret: "" # Will be set via Kubernetes secret
  authorityUrl: "" # Will be set via Kubernetes secret
  issuerUrl: ""     # Will be set via Kubernetes secret
  jwksUri: ""       # Will be set via Kubernetes secret
  userFlowName: "B2C_1_signupsignin"
  redirectUri: "http://localhost:3000/api/auth/callback/azure-ad-b2c"
  logoutRedirectUri: "http://localhost:3000"

# M2M Authentication (inter-service communication) - Values will be set via Kubernetes secrets
m2mAuth:
  enabled: true
  secretName: m2m-auth
  secretKey: ""  # Will be set via Kubernetes secret
  maxTimestampAge: 300  # 5 minutes
  nonceTtl: 600  # 10 minutes

# Frontend
frontend:
  enabled: true
  replicaCount: 1  # Reducido para ahorrar recursos
  image:
    repository: carpeta-frontend
    tag: latest
  service:
    type: LoadBalancer  # Público - acceso directo
    port: 80
    targetPort: 3000
  resources:
    requests:
      memory: "128Mi"   # Optimizado para recursos limitados
      cpu: "25m"        # Reducido significativamente
    limits:
      memory: "256Mi"  # Límite conservador
      cpu: "25m"      # Límite conservador
  autoscaling:
    enabled: true      # Habilitado para optimización
    minReplicas: 1
    maxReplicas: 3
    targetCPUUtilizationPercentage: 80
    targetMemoryUtilizationPercentage: 85
  podDisruptionBudget:
    enabled: true
    minAvailable: 1  # Mantener al menos 1 disponible
  # NextAuth configuration - Values will be set via Terraform
  nextAuth:
    secret: "" # Will be set via Kubernetes secret
    url: "" # Will be set via Kubernetes secret
    # Azure AD B2C configuration will be set via Terraform

    metrics:
      - type: Pods
        pods:
          metric:
            name: http_request_duration_seconds_p95
          target:
            type: AverageValue
            averageValue: "500m"  # 500ms p95 latency

# Citizen Service - Moderado uso
citizen:
  enabled: true
  replicaCount: 1  # Reducido para ahorrar recursos
  image:
    repository: carpeta-citizen
    tag: latest
  service:
    type: ClusterIP  # Interno - acceso vía Azure API Management
    port: 8000
  resources:
    requests:
      memory: "128Mi"   # Optimizado para recursos limitados
      cpu: "25m"        # Reducido significativamente
    limits:
      memory: "256Mi"  # Límite conservador
      cpu: "25m"
  autoscaling:
    enabled: true
    minReplicas: 1
    maxReplicas: 10
    targetCPUUtilizationPercentage: 70
  podDisruptionBudget:
    minAvailable: 1

# Ingestion Service - Genera SAS URLs, no sube archivos
ingestion:
  enabled: true
  replicaCount: 1  # Reducido para ahorrar recursos
  image:
    repository: carpeta-ingestion
    tag: latest
  service:
    type: ClusterIP  # Interno - acceso vía Azure API Management
    port: 8000
  resources:
    requests:
      memory: "128Mi"   # Optimizado para recursos limitados
      cpu: "25m"        # Reducido significativamente
    limits:
      memory: "256Mi"  # Límite conservador
      cpu: "25m"
  autoscaling:
    enabled: true
    minReplicas: 1
    maxReplicas: 15
    targetCPUUtilizationPercentage: 70
  podDisruptionBudget:
    minAvailable: 1

# Signature Service - Alto CPU (criptografía)
signature:
    enabled: true
    replicaCount: 1  # Reducido para ahorrar recursos
    image:
      repository: carpeta-signature
      tag: latest
    service:
      type: ClusterIP  # Interno - acceso vía Azure API Management
      port: 8000
    resources:
      requests:
        memory: "256Mi"  # Aumentado para evitar OOM
        cpu: "25m"        # Reducido significativamente
      limits:
        memory: "256Mi"  # Límite para prevenir OOM
        cpu: "25m"       # Reducido pero suficiente
    autoscaling:
      enabled: true
      minReplicas: 1
      maxReplicas: 10
      targetCPUUtilizationPercentage: 70
    podDisruptionBudget:
      minAvailable: 1

# Metadata Service - Búsquedas en OpenSearch
metadata:
  enabled: true
  replicaCount: 1  # Reducido para ahorrar recursos
  image:
    repository: carpeta-metadata
    tag: latest
  service:
    type: ClusterIP  # Interno - acceso vía Azure API Management
    port: 8000
  resources:
    requests:
      memory: "128Mi"   # Optimizado para recursos limitados
      cpu: "25m"        # Reducido significativamente
    limits:
      memory: "256Mi"  # Límite conservador
      cpu: "25m"
  autoscaling:
    enabled: true
    minReplicas: 1
    maxReplicas: 10
    targetCPUUtilizationPercentage: 70
  podDisruptionBudget:
    minAvailable: 1

# Transfer Service - Saga pattern, transaccional
transfer:
  enabled: true
  replicaCount: 1  # Reducido para ahorrar recursos
  image:
    repository: carpeta-transfer
    tag: latest
  service:
    type: ClusterIP  # Interno - acceso vía Azure API Management (cambiar de LoadBalancer)
    port: 8000
  resources:
    requests:
      memory: "256Mi"  # Optimizado para recursos limitados
      cpu: "25m"       # Reducido
    limits:
      memory: "256Mi"  # Límite para evitar OOM durante sagas complejas
      cpu: "25m"     # Puede necesitar CPU para procesamiento concurrente
  autoscaling:
    enabled: true
    minReplicas: 1
    maxReplicas: 10
    targetCPUUtilizationPercentage: 70
  podDisruptionBudget:
    minAvailable: 1  # Critical for saga orchestration


# Notification Service - DISABLED - not required by reference document
# notification:
#   enabled: false

# MinTIC Client Service - Rate limiter + Hub calls
minticClient:
  enabled: true
  replicaCount: 1  # Reducido para ahorrar recursos
  image:
    repository: carpeta-mintic_client
    tag: latest
  service:
    type: ClusterIP  # Interno - llamado por otros servicios
    port: 8000
  resources:
    requests:
      memory: "256Mi"  # HTTP client + rate limiter
      cpu: "25m"
    limits:
      memory: "256Mi"  # Límite conservador
      cpu: "25m"
  autoscaling:
    enabled: true
    minReplicas: 1
    maxReplicas: 10
    targetCPUUtilizationPercentage: 70
  podDisruptionBudget:
    minAvailable: 1

# Read Models Service (CQRS) - Consumidor de eventos
readModels:
  enabled: true
  replicaCount: 1
  image:
    repository: carpeta-read_models
    tag: latest
  service:
    type: ClusterIP  # Interno - acceso vía Azure API Management
    port: 8007
  resources:
    requests:
      memory: "128Mi"  # Event consumer + queries simples
      cpu: "25m"
    limits:
      memory: "256Mi"  # Límite conservador
      cpu: "25m"
  autoscaling:
    enabled: true
    minReplicas: 1
    maxReplicas: 10
    targetCPUUtilizationPercentage: 70
  podDisruptionBudget:
    minAvailable: 1

# Auth Service - OIDC Provider + Azure AD B2C
auth:
  enabled: true
  replicaCount: 1
  image:
    repository: carpeta-auth
    tag: latest
  service:
    type: ClusterIP  # Interno - acceso vía Azure API Management
    port: 8000
  resources:
    requests:
      memory: "64Mi"  # Token validation + session management
      cpu: "25m"
    limits:
      memory: "128Mi"  # Límite conservador
      cpu: "25m"
  autoscaling:
    enabled: true
    minReplicas: 1
    maxReplicas: 10
    targetCPUUtilizationPercentage: 70

# Transfer Worker - Dedicated consumer for transfers (KEDA auto-scaling)
transferWorker:
  enabled: true  # Enabled now that KEDA is installed
  replicaCount: 0  # KEDA controls replicas (scales from 0)
  image:
    repository: carpeta-transfer-worker
    tag: latest
  service:
    type: ClusterIP  # Interno - solo métricas
    port: 8012
  
  # Worker configuration
  queueName: "transfers"
  maxConcurrent: 10  # Max concurrent messages per pod
  prefetchCount: 20  # Prefetch messages for performance
  maxWaitTime: 60    # Max seconds to wait for messages
  
  # Resources (optimized for spot instances)
  resources:
    requests:
      memory: "256Mi"  # Message processing + DB connections
      cpu: "25m"
    limits:
      memory: "256Mi"  # Limit to prevent OOM
      cpu: "25m"     # Can spike during high load
  
  # KEDA auto-scaling configuration
  keda:
    enabled: false  # Disabled for Azure for Students
    pollingInterval: 30  # Check queue every 30 seconds
    cooldownPeriod: 300   # Wait 5 minutes before scaling down
    minReplicas: 0        # Scale to zero when queue is empty
    maxReplicas: 30       # Maximum replicas under load
    fallbackReplicas: 3   # Fallback if metrics unavailable
    scaleDownStabilization: 300  # Wait 5 min before scale down
    
    # Queue metrics
    queueName: "transfers"
    targetQueueLength: 5  # Target 5 messages per pod
    activationThreshold: 1  # Activate from 0 when 1+ messages
    triggerAuthName: "azure-servicebus-auth"
    
    # Additional triggers (optional)
    cpuTrigger:
      enabled: false
      targetUtilization: 70
    memoryTrigger:
      enabled: false
      targetUtilization: 80
  
  # Node selector for spot instances
  nodeSelector:
    workload: "workers"
    kubernetes.azure.com/scalesetpriority: "spot"
  
  # Tolerations for spot instances
  tolerations:
  - key: "kubernetes.azure.com/scalesetpriority"
    operator: "Equal"
    value: "spot"
    effect: "NoSchedule"
  
  # Anti-affinity (spread across nodes)
  affinity:
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
            - key: app
              operator: In
              values:
              - transfer-worker
          topologyKey: kubernetes.io/hostname

    useMaxUnavailable: true
    maxUnavailable: 50%  # During operation, allow disrupting 50% at a time
  
  # Autoscaling configuration
  autoscaling:
    enabled: true
    minReplicas: 1
    maxReplicas: 5
    targetCPUUtilizationPercentage: 70

# PostgreSQL Configuration (Azure Database for PostgreSQL) - Values will be set via Kubernetes secrets
database:
  connectionString: "" # Will be set via Kubernetes secret
  host: "" # Will be set via Kubernetes secret
  port: 5432
  username: "" # Will be set via Kubernetes secret
  password: "" # Will be set via Kubernetes secret
  database: "carpeta_ciudadana"

postgresql:
  enabled: true
  host: "" # Will be set via Kubernetes secret
  port: 5432
  auth:
    username: "" # Will be set via Kubernetes secret
    password: "" # Will be set via Kubernetes secret
    database: carpeta_ciudadana

# Redis Configuration - Values will be set via Kubernetes secrets
redis:
  host: "" # Will be set via Kubernetes secret
  port: 6379
  password: "" # Will be set via Kubernetes secret
  ssl: false

# Azure Storage Configuration - Values will be set via Kubernetes secrets
azure:
  storage:
    accountName: "" # Will be set via Kubernetes secret
    accountKey: "" # Will be set via Kubernetes secret
    containerName: "documents"
    sasTtlMinutes: 15

# Circuit Breaker Configuration
circuitBreaker:
  window: "60s"
  threshold: 5
  cooldown: "120s"

# Service Bus Configuration
serviceBus:
  enabled: true
  connectionString: "" # Will be set via Kubernetes secret
  namespace: "" # Service Bus namespace (e.g., carpeta-sb) - for KEDA

# Observability Configuration
observability:
  enabled: false  # Disabled for Azure for Students
  otel:
    endpoint: "http://otel-collector-opentelemetry-collector.observability.svc.cluster.local:4317"
  # prometheus: # Removed - using Azure Monitor instead
    enabled: false  # Disabled for Azure for Students
    scrapeInterval: 30s

# CORS Configuration
cors:
  allowedOrigins: "*"  # Overridden in values-dev.yaml and values-prod.yaml
  allowCredentials: false

# OpenSearch Configuration - Using external OpenSearch in 'search' namespace
# External OpenSearch endpoint for metadata service
opensearch:
  external:
    host: "opensearch-cluster-master.search.svc.cluster.local"
    port: 9200
    protocol: "http"

# Configuration
mintic:
  hubUrl: "" # Will be set via Kubernetes secret
  allowInsecureUrls: false
  rateLimit: 10
  operatorId: "" # Will be set via Kubernetes secret
  operatorName: "" # Will be set via Kubernetes secret

otel:
  enabled: true
  endpoint: http://jaeger-collector:4317

# Service Account (for Workload Identity)
serviceAccount:
  create: true
  annotations: {}
  name: carpeta-ciudadana-sa

# Network Policies (Zero-Trust Networking)
networkPolicies:
  enabled: true  # Set to true to enable (requires NetworkPolicy support in AKS)
  denyAllByDefault: true  # Deny all traffic by default, allow only specific
  allowDNS: true  # Always allow DNS resolution
  allowObservability: true  # Allow Azure Monitor scraping

# Pod Disruption Budgets (High Availability)
podDisruptionBudget:
  enabled: false  # Disabled temporarily to fix template issues
  # Global defaults (can be overridden per service)
  defaultMinAvailable: 1  # At least 1 pod must be available during disruptions


# Ingress - Configurado para usar dominios generados por Azure
ingress:
  enabled: true
  className: nginx  # Use 'nginx' for cert-manager
  annotations:
    # Azure Load Balancer annotations
    service.beta.kubernetes.io/azure-load-balancer-internal: "false"
    service.beta.kubernetes.io/azure-load-balancer-resource-group: "rg-carpeta-ciudadana"
    
    # Nginx Ingress Controller annotations
    nginx.ingress.kubernetes.io/ssl-redirect: "false"  # Disabled for HTTP-only setup
    nginx.ingress.kubernetes.io/force-ssl-redirect: "false"
    nginx.ingress.kubernetes.io/proxy-body-size: "10m"
    nginx.ingress.kubernetes.io/client-body-buffer-size: "1m"
    
    # Rate limiting
    nginx.ingress.kubernetes.io/limit-rps: "100"
    nginx.ingress.kubernetes.io/limit-burst-multiplier: "5"
    
    # Timeouts
    nginx.ingress.kubernetes.io/proxy-connect-timeout: "60"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "60"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "60"
  
  # Rate limiting
  rateLimitRps: 100  # Requests per second per IP
  
  tls:
    enabled: false  # Disabled for HTTP-only setup with Azure-generated domains
    secretName: carpeta-ciudadana-tls
    certManager:
      enabled: false  # Disabled for HTTP-only setup
      
  hosts:
    # Usar dominio generado por Azure Load Balancer
    # El dominio se obtendrá automáticamente del LoadBalancer IP
    - host: ""  # Dejar vacío para usar LoadBalancer IP
      paths:
        # API routing through internal gateway
        - path: /api
          pathType: Prefix
          backend:
            service:
              name: gateway
              port: 8000
        # Frontend (public) - Serves static assets and UI
        - path: /
          pathType: Prefix
          backend:
            service:
              name: frontend
              port: 80

# OpenTelemetry Collector
otel:
  enabled: true
  replicaCount: 1
  resources:
    requests:
      memory: "256Mi"
      cpu: "25m"
    limits:
      memory: "256Mi"
      cpu: "25m"

